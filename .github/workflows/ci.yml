name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  pull-requests: read

env:
  GO_VERSION: "1.24.2"

jobs:
  # Build
  build:
    name: Build
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go Environment
        uses: ./.github/actions/setup-go
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Build
        uses: ./.github/actions/build

  # Linting, formatting, and static analysis
  lint:
    name: Lint & Static Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go Environment
        uses: ./.github/actions/setup-go
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v8
        with:
          version: latest

      - name: Run go vet
        run: go vet ./...

      - name: Run go fmt check
        run: |
          # Check if code is properly formatted
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "Code is not formatted. Run 'gofmt -s -w .' to fix formatting."
            gofmt -s -l .
            exit 1
          fi
          echo "Code formatting is correct."

  # Unit tests with coverage
  unit-tests:
    name: Unit Tests & Coverage
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: build

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go Environment
        uses: ./.github/actions/setup-go
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Run tests with coverage
        run: |
          # Run tests on all packages except proto directory (with -short to skip integration tests requiring external servers)
          go test -short -v -race -coverprofile=coverage.out -covermode=atomic $(go list ./... | grep -v '/proto')

      - name: Generate coverage report
        run: go tool cover -html=coverage.out -o coverage.html

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v5
        with:
          file: ./coverage.out
          token: ${{ secrets.CODECOV_TOKEN }}
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

  # Integration tests
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: build

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go Environment
        uses: ./.github/actions/setup-go
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Run Integration Tests
        uses: ./.github/actions/integration-tests
        with:
          script-path: examples/run_integration_tests.sh
          parallel-jobs: 4
          timeout: 30s

      - name: Run Vector DB Integration Tests
        run: |
          echo "Running Qdrant integration tests with testcontainers..."
          go test -tags=integration -v -timeout=10m ./pkg/middleware/retrieval/qdrant/

  # Security scanning
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go Environment
        uses: ./.github/actions/setup-go
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Clean environment
        run: |
          # Clean any existing installations
          rm -rf ~/go/bin/govulncheck || true
          rm -rf /tmp/govulncheck* || true

          # Verify clean state
          echo "Cleaning environment for security scan..."

      - name: Install govulncheck
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest

      - name: Run security vulnerability scan
        run: |
          govulncheck ./... > security-report.txt 2>&1 || true
          echo "Security scan completed"

          # Count vulnerabilities found
          VULNS=$(grep -c "Vulnerability #" security-report.txt 2>/dev/null || echo "0")
          echo "issues=$VULNS" >> $GITHUB_OUTPUT
          echo "Found $VULNS security vulnerabilities"

          # Display report
          if [ -f "security-report.txt" ]; then
            echo "=== Security Scan Report ==="
            cat security-report.txt
          fi

      - name: Upload security report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-report
          path: security-report.txt
